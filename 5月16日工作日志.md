

# 5月16日工作日志

今天完成了文件流的下载和模板类的生成，并完成了与前端的一个数据接口，了解了httpservletresponse和httpservletrequest的基本用法。



## HttpServletRequest 详解

HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。

# HttpServletResponse

HttpServletResponse详解
Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对 象。
request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。

**HttpServletResponse \*addHeader\*() 与 setHeader() 区别**

setHeader(name, value)：如果Header中没有定义则添加，如果已定义则用新的value覆盖原用value值。

addHeader(name, value)：如果Header中没有定义则添加，如果已定义则保持原有value不改变。



## InputStream输入流

[**InputStream**] (字节输入流)类是一个抽象类

所有的输入流都是InputStream直接或间接的[子类]

int read()    //从输入流中读取单个字节，返回所读取的字节数据

int read(byte[] b)    //从输入流中读取最多b.length长度的字节，并存储在字节数组b中，返回实际读取的字节数。

int read(byte[] ,b,int off,int len)  //从输入流中读取最多len长度的字节，保存到字节数组b中，保存的位置从off开始。

void close()    //关闭输入流

int available()    //返回可以从输入流中读取的字节数目

skip(long n)     //从输入流中跳过参数n指定数目的字节。

mar(int readlimit)   //标记输入流中的当前位置，以便可使用reset()方法复位到该标记的位置。

void reset()     //将当前位置复位为上次调用mark()方法标记的位置.

# 模板的工具类、文件流的传输

```java
package com.kenfor.zshp.service.genword;

import com.kenfor.zshp.controller.TestController;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.Version;
import org.slf4j.ILoggerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.net.URLEncoder;
import java.util.Map;

/**
 * Word文档工具类
 */
public class WordUtil {

    /**
     * 使用FreeMarker自动生成Word文档
     * @param dataMap   生成Word文档所需要的数据
     * @param fileName  生成Word文档的全路径名称
     */
    private static Logger logger = LoggerFactory.getLogger(WordUtil.class);
    public static void generateWord(Map<String, Object> dataMap, String fileName) throws Exception {
        // 设置FreeMarker的版本和编码格式
        Configuration configuration = new Configuration(new Version("2.3.31"));
        configuration.setDefaultEncoding("UTF-8");

        // 设置FreeMarker生成Word文档所需要的模板的路径
        /**
         * system.getProperty  获取用户的当前工作目录
         */
//        final String path = System.getProperty("user.dir");
//        configuration.setDirectoryForTemplateLoading(new File("C:\\Users\\lenovo\\Desktop\\project\\GenerateWord\\resources\\"));

//        获取到模板地址
        final String templateFileRootPath = com.kenfor.global.Configuration.getInstance().getValue("templateFileRootPath");
//        final String directoryForTemplateLoading = templateFileRootPath + "\\wordtemp\\";
//        final String directoryForTemplateLoading = templateFileRootPath + "\\testtemp\\";
        //      修改模板内的信息
        configuration.setDirectoryForTemplateLoading(new File(templateFileRootPath));

        // 设置FreeMarker生成Word文档所需要的模板
        Template t = configuration.getTemplate("test.ftl", "UTF-8");
        // 创建一个Word文档的输出流
        Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(fileName)), "UTF-8"));
        //FreeMarker使用Word模板和数据生成Word文档
        t.process(dataMap, out);
        out.flush();
        out.close();
    }

    /**
     * 文件下载
     * @param path 文件路径全路径，包含文件名
     */
    public static void downLoadFile(HttpServletResponse response, String path) throws IOException {
        try {
            // path是指欲下载的文件路径
            File file = new File(path);
            //  取得文件名
            String filename = file.getName();

            // 以流的形式下载文件
            InputStream fis = new BufferedInputStream(new FileInputStream(path));
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            fis.close();
            //清空response
            response.reset();
            //设置response的Header
            String fileName = URLEncoder.encode(filename,"UTF-8");
            response.addHeader("Content-Disposition","attachment;filename="+fileName);
            response.addHeader("Content-Length",""+file.length());
            response.setContentType("application/octet-stream");
            OutputStream toClient = new BufferedOutputStream(response.getOutputStream());
            toClient.write(buffer);
            toClient.flush();
            toClient.close();
        } catch (Exception e) {
            e.printStackTrace();
            logger.error("文件下载错误");
        }
    }
}

```

